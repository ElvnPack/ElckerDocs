(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{437:function(n,e,t){"use strict";t.r(e);var o=t(21),r=Object(o.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h2",{attrs:{id:"mock"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mock"}},[n._v("#")]),n._v(" mock")]),n._v(" "),t("p",[n._v("环境配置参数： VITE_USE_MOCK")]),n._v(" "),t("p",[n._v("mock 的开启由该参数与环境配合启用：")]),n._v(" "),t("p",[n._v("开发环境下启用本地 mock 禁用线上 mock;")]),n._v(" "),t("p",[n._v("测试环境下禁用本地 mock 并禁用线上 mock;")]),n._v(" "),t("p",[n._v("生产环境下禁用本地 mock 并启用线上 mock")]),n._v(" "),t("p",[n._v("注意：最终的结果以 VITE_USE_MOCK 配置为主导。")]),n._v(" "),t("h3",{attrs:{id:"新增-mock-接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#新增-mock-接口"}},[n._v("#")]),n._v(" 新增 mock 接口")]),n._v(" "),t("p",[n._v("本地 mock 采用 Node.js 中间件进行参数拦截，")]),n._v(" "),t("div",{staticClass:"language-nodejs extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import { MockMethod } from 'vite-plugin-mock';\n\n// const demo ={\n//     // 请求地址\n//     url: string;\n//     // 请求方式\n//     method?: MethodType;\n//     // 设置超时时间\n//     timeout?: number;\n//     // 状态吗\n//     statusCode?:number;\n//     // 响应数据（JSON）\n//     response?: ((opt: { [key: string]: string; body: Record<string,any>; query:  Record<string,any>, headers: Record<string, any>; }) => any) | any;\n//     // 响应（非JSON）\n//     rawResponse?: (req: IncomingMessage, res: ServerResponse) => void;\n//   }\n\nexport default [\n  {\n    url: '/api/get',\n    method: 'get',\n    response: () => {\n      return {\n        code: 0,\n        data: {\n          name: 'vben',\n        },\n      };\n    },\n  },\n  {\n    url: '/api/post',\n    method: 'post',\n    timeout: 2000,\n    response: {\n      code: 0,\n      data: {\n        name: 'vben',\n      },\n    },\n  },\n  {\n    url: '/api/text',\n    method: 'post',\n    rawResponse: async (req, res) => {\n      let reqbody = '';\n      await new Promise((resolve) => {\n        req.on('data', (chunk) => {\n          reqbody += chunk;\n        });\n        req.on('end', () => resolve(undefined));\n      });\n      res.setHeader('Content-Type', 'text/plain');\n      res.statusCode = 200;\n      res.end(`hello, ${reqbody}`);\n    },\n  },\n] as MockMethod[];\n\n")])])]),t("p",[n._v("API 与 mock 匹配")]),n._v(" "),t("blockquote",[t("p",[n._v("保存 api 的请求地址与请求类型与定义的 mock 接口一致即可")])]),n._v(" "),t("h2",{attrs:{id:"服务器交互"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#服务器交互"}},[n._v("#")]),n._v(" 服务器交互")]),n._v(" "),t("p",[n._v("1.服务器的交互及跨域的配置参见项目配置插件 server")]),n._v(" "),t("p",[n._v("2.建议使用"),t("a",{attrs:{href:"https://hellosean1025.github.io/yapi/",target:"_blank",rel:"noopener noreferrer"}},[n._v("YAPI"),t("OutboundLink")],1),n._v("进行线上接口模拟，功能强大实用。")])])}),[],!1,null,null,null);e.default=r.exports}}]);